from PyQt5.QtWidgets import QMainWindow, QApplication, QPushButton, QWidget, QTabWidget, QVBoxLayout, \
    QFileDialog, QGridLayout, QLabel, QComboBox, QCheckBox, QMessageBox, QDesktopWidget, \
    QProgressBar, QLineEdit, QInputDialog, QGroupBox, QFormLayout
from PyQt5.QtGui import QDoubleValidator
from PyQt5.QtCore import *
from PyQt5.QtCore import pyqtSlot
import sys
from SixFrameTranslation import *
from time import time
import platform
import os

# set min ratio of available RAM to input file size. With 56Gb of RAM, the program runs a file of 7Gb comfortably.
# Thus setting the min to 56Gb/8Gb = 7
RAM_TO_FILE_MIN = 7

class WorkerSignals(QObject):
    """
    Signals class that is used by QRunnable classes to emit customised signals to the rest of the code.
    """

    finished = pyqtSignal()

class OutputGenerator(QRunnable):
    """
    OutputGenerator QRunnable class is used run the computational side of the program in a thread so that the user
    interface doesn't become unresponsive. It simply runs a worker function and then emits the finished signal, which
    will be connected to a specific function, when finished.
    """

    def __init__(self, fn, *args, **kwargs):
        super(OutputGenerator, self).__init__()
        # Store constructor arguments (re-used for processing)
        self.fn = fn
        self.args = args
        self.kwargs = kwargs
        self.signals = WorkerSignals()

    @pyqtSlot()
    def run(self):
        self.fn(*self.args)
        self.signals.finished.emit()


class Example(QWidget):

    """
    The Example widget forms the main window of the user interface. It is created and dislayed on the screen when
    SizFrameGUI.py is run.
    """

    def __init__(self):
        """
        Called when the widget is created. This function simply declares a few of the variables which are required to
        control the flow of the program.

        self.inputFile: the path of the input file, which is updated when the user uploads the input file.
        self.minProteinLen: the minimum length a protein must be for it to be included in the final output.
        self.originFlag: stores a boolean detailing if the user wants to include the origins of the translated
        proteins (False) or if they would like to ignore the origin data (True).
        self.writeSubFlag: stores a boolean which is True if the user wants to write an output file with all the
        proteins that were deleted for being subsets of other proteins in the output.
        self.removeSubFlag: a boolean which is True if the user want to produce an output file without proteins that
        are found as subsets of other proteins in the output.
        self.threadpool: a QThreadPool variables which is used to manage multiprocessing of the GUI.
        """
        super().__init__()
        self.initUI()
        self.inputFile = ""
        self.minProteinLen = 0
        self.originFlag = ""
        self.writeSubFlag = ""
        self.removeSubFlag = ""
        self.threadpool = QThreadPool()

    def initUI(self):
        """
        Called by the class's initialiser function, this function simply sets the layout of the Example widget, creates
        all the widgets and inserts them to this Grid layout. It then shows the Example widget on the screen and
        creates a variable to store the path of the output file/s.
        :return:
        """

        self.grid = QGridLayout()
        self.setLayout(self.grid)

        self.initialiseWidgets()

        self.move(300, 150)
        self.setWindowTitle('DNA to Protein')
        self.show()

        self.outputPath = None

    def closeEvent(self, event):
        """
        Called automatically on click of the exit button. This function is configured to test if the system is being
        run on windows or mac, and uses the appropriate command to close the window and kill all processes which were
        generated by the program.

        :param event: details that close event is taking place.
        :return:
        """
        print('closed')
        # windows close command
        if platform.system() == 'Windows':
            os.system('taskkill /f /fi "WINDOWTITLE eq DNA to Protein" /t')
        # mac close command
        else:
            os.system("ps aux |grep SixFrameGUI | grep -v 'pattern_of_process_you_dont_want_to_kill' | awk '{print $2}' |xargs kill")

    def initialiseWidgets(self):
        """
        Called from self.initIU(), this function creates all the widgets which are to be added to the interface and
        adds tehm to the grid layout.
        :return:
        """
        self.importDNA = QPushButton('Import DNA fasta')
        self.grid.addWidget(self.importDNA, 1, 1)
        self.importDNA.clicked.connect(self.uploadInput)

        self.minLenCombo = QComboBox()
        self.minLenLabel = QLabel('Minimum Protein Length: ')
        self.grid.addWidget(self.minLenCombo, 2,2)
        self.grid.addWidget(self.minLenLabel, 2,1)
        for i in range(2, 15):
             self.minLenCombo.addItem(str(i))

        self.removeSubseq = QCheckBox('Remove Subsequences')
        self.removeSubseq.stateChanged.connect(self.disableCheckboxes)
        self.ignoreOrigin = QCheckBox('Ignore Origin')
        self.ignoreOrigin.setEnabled(False)
        self.writeSubseq = QCheckBox('Print Deleted Subseq')
        self.writeSubseq.setEnabled(False)
        self.grid.addWidget(self.removeSubseq, 3, 1)
        self.grid.addWidget(self.ignoreOrigin, 4, 1)
        self.grid.addWidget(self.writeSubseq, 3, 2)

        self.generateOutput = QPushButton('Generate Output')
        self.grid.addWidget(self.generateOutput, 5,1)
        self.generateOutput.clicked.connect(self.outputCheck)

    def uploadInput(self):
        """
        Called on click of the self.importDNA button, this function opens a window for the user to select the path of
        the fasta file containing DNA sequences that they wish to apply six frame translation to. Once a file is
        selected the user checks that a valid fasta file has been uploaded, and also checks that the file is not so
        large that it will exceed the RAM of the computer being used.
        :return:
        """
        fname = QFileDialog.getOpenFileName(self, 'Open File', '/home/')
        fileSize = os.stat(fname[0]).st_size
        memAvail = psutil.virtual_memory().available
        ratio = memAvail/fileSize
        # basic check to ensure that the input fasta file will not use more RAM than the computer has to offer.
        # the minimum ratio of memory available to file size that allows safe running of the program was experimentally
        # derived. If the ratio of the input is lower than this, the test is stopped from running.
        if ratio < RAM_TO_FILE_MIN:
            QMessageBox.about(self, 'Message', 'This file is too large for the program to handle.\nTry splitting in half and re-uploading!')
        elif fname[0][-5:] == 'fasta':
            print('in')
            self.inputFile = fname[0]
            QMessageBox.about(self, 'Message', 'Fasta input file successfully uploaded!')

    def disableCheckboxes(self):
        """
        Called every time the self.removeSubseq checkbox changes state. This function simply enables the
        self.writeSubseq and self.ignoreOrigin flag is self.removeSubseq is checked.
        :return:
        """
        if self.removeSubseq.isChecked():
            self.writeSubseq.setEnabled(True)
            self.ignoreOrigin.setEnabled(True)
        else:
            self.writeSubseq.setChecked(False)
            self.ignoreOrigin.setChecked(False)
            self.writeSubseq.setEnabled(False)
            self.ignoreOrigin.setEnabled(False)

    def outputCheck(self):
        """
        Called on click of the self.generateOutput button. This function checks that a valid fasta file has been input
        and then creates a QMessageBox which gets the user to confirm their input parameters. Once confirmed,
        self.getOutputPath() is called.
        :return:
        """
        if self.inputFile == "":
            QMessageBox.about(self, 'Message', 'Please Upload a Fasta File before generating output!')
        else:
            minString= self.minLenCombo.currentText()
            self.minProteinLen = int(minString)
            self.removeSubFlag = self.removeSubseq.isChecked()
            self.writeSubFlag = self.writeSubseq.isChecked()
            self.originFlag = self.ignoreOrigin.isChecked()
            reply = QMessageBox.question(self, 'Message', 'Do you wish to confirm the following input?\n' +
                                          'Minimum Protein Length: ' + minString + '\n' +
                                          'Remove Subsequences: ' + str(self.removeSubFlag) + '\n' +
                                          'Write Subsequences to File: ' + str(self.writeSubFlag) + '\n' +
                                          'Ignore Origin Sequences: ' + str(self.originFlag) + '\n' +
                                          'Input File ' + self.inputFile)
            if reply == QMessageBox.Yes:
                self.getOutputPath()

    def getOutputPath(self):
        """
        Called by self.outputCheck() after generate output is clicked and the user confirms their input. Opens a
        window to select a file location to save the output to, and if valid opens a window to input the file name.
        :return:
        """
        # opens a window to select file location.
        self.outputPath = str(QFileDialog.getExistingDirectory(self, "Select Directory"))

        # if no outout path is returned, simply return to the main GUI and the user can choose to recommence the file location
        # selection process if they desire.
        if self.outputPath == '':
            return
        # else if a valid path is selected, bring up a dialog to input the file name
        else:
            self.filePathDialog()

    def filePathDialog(self):
        """
        Called by self.getOutputPath after a valid output path has been selected. This function creates a pop-up widget
        which allows the user to input a file name for the output file.
        """
        self.outputNameBox = QGroupBox('Output Name')
        self.outputNameLayout = QFormLayout()
        self.outputNameLayout.addRow(QLabel("Add a name for the output file."))
        self.outputNameLayout.addRow(QLabel('Banned characters: \ / : * " < > |'))
        self.fileName = QLineEdit()
        self.fileName.textChanged[str].connect(self.nameChecker)
        self.button = QPushButton("Create Output")
        self.valid = QLabel("Valid")
        self.button.clicked.connect(self.returnPath)
        self.outputNameLayout.addRow(self.fileName, self.valid)
        self.outputNameLayout.addRow(self.button)
        self.outputNameBox.setLayout(self.outputNameLayout)
        self.outputNameBox.show()

    def nameChecker(self, input):
        """
        This function is called every time the file name lineEdit is updated. It takes the param input, which is the
        text in the lineEdit, and checks if it is a valid file name.
        :param input: the text in the line-edit that is to have its validity checked.
        """
        # assign bannedCharacters to variables.
        bannedCharacters = set('\/:*"<>|')
        # if the input has no intersection with the banned characters it is valid. If so, update the label validity label
        # and set ensure the generate output button is concurrently enabled/disabled.
        if len(set(input).intersection(bannedCharacters)) == 0:
            self.valid.setText("Valid")
            self.button.setEnabled(True)
        else:
            self.valid.setText("Invalid")
            self.button.setEnabled(False)

    def returnPath(self):
        """
        Called on click of self.button, the button which the user clicks when they wish to confirm a valid file name
        for the output file. This function creates an OutputGenerator QRunnable object which runs seld.createOutput()
        as its worker function. It then closes the naming pop-up window and adds a label to the QWidget detailing that
        the output is underway.
        :return:
        """
        start = time()
        # create the output file name by combining path with the name.
        outputFile = self.outputPath + '/' + self.fileName.text()
        print(outputFile)
        self.outputGen = OutputGenerator(self.createOutput, outputFile)
        self.outputGen.signals.finished.connect(self.outputFinished)
        self.threadpool.start(self.outputGen)
        self.outputLabel = QLabel("Generating Output. Please Wait!")
        self.grid.addWidget(self.outputLabel, 7, 1)
        end = time()
        print(end - start)
        # close the output name box.
        self.outputNameBox.close()

    def createOutput(self, outputPath):
        """
        This function is the worker function to the OutputGenerator object created in self.returnPath(). It simply
        calls generateOutputNew() in SixFrameTranslation.py to initiate the six frame translation of the input DNA
        sequences.

        :param outputPath: the exact file path the output file is to be written to.
        :return:
        """
        generateOutputNew(outputPath, self.minProteinLen, self.inputFile, self.removeSubFlag, self.writeSubFlag, self.originFlag)

    def outputFinished(self):
        """
        Called via the finished signal when self.createOutput() has finished running as the worker function to the
        OutputGenerator thread. This function simply removes the label which tells the user the output is running and
        displays a message detailing that the program has finished.
        :return:
        """
        QMessageBox.about(self, "Message", "All done!")
        self.grid.removeWidget(self.outputLabel)
        self.outputLabel.deleteLater()
        self.outputLabel = None

if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())